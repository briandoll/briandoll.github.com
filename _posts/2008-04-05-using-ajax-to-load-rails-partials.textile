---
layout: post
title: Using AJAX to load Rails partials
---

h1. {{ page.title }}

I had an excuse recently to try something I thought was going to be trivial, what with all the kids using AJAX these days.  Unfortunately since I wasn't trying to create another "live search feature":http://www.google.com/search?hl=en&amp;q=rails+ajax+live+search&amp;btnG=Google+Search, documentation, blog postings and "several":http://www.amazon.com/Rails-Way-Addison-Wesley-Professional-Ruby/dp/0321445619 "books":http://www.pragprog.com/titles/cppsu/ on the "subject":http://www.pragprog.com/titles/rails2 were surprisingly lacking.

See, all I was trying to do was to load a page fragment, or partial in rails speak, in an asynchronous way.  While this doesn't sound very glamorous, its a great way to make your web application _feel_ more responsive when you have a particularly heavy weight partial to deal with.

*An Example:*
A page within your web application displays your site layout, a menu or two, some paginated flummoxes, topped with a lovely, glass like logo that is showing it's bright and shiny reflection on some strange surface that shields your website from anything that might fall from the address bar.

Toward the bottom of the page, you display some recommended flummoxes, based on whatever flummoxes the user has visited recently.  <small>(As you can surely tell, this example  is not only made up, but is quite far from the more complex scenario that led me down this path in the first place.  "As we know, creating example code is a PITA.":http://blog.jayfields.com/2008/03/example-dilemma.html) </small> This recommendation flummox feature is a real drag.  It can take seemingly forever to render since it involves a few complex queries, and of course a REST call or two.  Wouldn't it be great if you could render the whole page, minus the flummox recommender, and have that feature filled in once it responds?  Exactly.

The Call to Action

{% highlight ruby %}http://localhost:3000/browse{% endhighlight %}

Note that this request is (likely) handled by a BrowseController.  The important thing to realize is that we need to pull out the slow, heavy logic that would normally drive the content in that slow flummox recommender feature and put it elsewhere.  In our example, we'll pull it out into its own, new controller.

*The Controller*
Here we have our controller, which will coordinate our requests to our model, as well as make a web service call or two:

{% highlight ruby %}
class SlowController < ApplicationController
  def super_slow_action_call
    @query_results = some_model.find(:all)
    @type = "name_of_real_partial_to_load"
    @heavy_data = some_slow_method_call(@query_results)
    render :partial =&gt; "load"
  end
end
{% endhighlight %}

Notice that render line?  We'll come back to that in a minute.
*The View*
index.html.erb (This is rendered by the original call to BrowseController, our otherwise fast loading page.)

{% highlight ruby %}
<%  @some_awesome_erb_here %>
. . .
<% javascript_tag do -%>
  new Ajax.Request("<%= url_for :controller => :slow, 
    :action => :super_slow_action_call %>", { method:'get'});
<% end -%>

<div id="name_of_real_partial_to_load"></div>
{% endhighlight %}

Aha!  There's our AJAX!  You'll notice that I have to actually type some JavaScript there.  I am alive to talk about it, but I sure don't like to dirty my hands in it.  If this pattern seems useful to folks, I may try to submit a patch to one of the rails helpers (JavaScript or Prototype helper) to make this a bit less dirty.

So what are we doing there?  We're creating a new Ajax.Request, thanks to our beloved  "Prototype JavaScript library":http://prototypejs.org/, and feeding it a URL to request via a GET method.  We can use the url_for helper to clean that up a bit, so it's not too nasty.

*Our erb partial:*
You've probably already built the code for the partial that displays those flummox recommendations, right?  Notice that @type variable in our controller?  We set that to "name_of_real_partial_to_load", so let's create app/slow/_name_of_real_partial_to_load.html.erb

{% highlight ruby %}
Here are some flummoxes you might like:<br/>
<% @heavy_data.each do |flx|%>
  <li><%= link_to flx.name, :action => :flx, :id => flx %>
<% end %>
{% endhighlight %}

Great, but how do we get that to render?  We made a call to load "load" from the super_slow_action_call action in our SlowController!

*Our RJS View, the glue to load them all!*
app/slow/_load.rjs

{% highlight ruby %}
page.insert_html :bottom, @type, :partial => @type, :object => @heavy_data
page.visual_effect :highlight, @type, :duration => 1.5
{% endhighlight %}

Here, we're inserting our partial (@type), into a div by the same name (@type), within the original view serving the request.

Since it is such a slow loading page fragment, we mine as well draw some attention to it once it gets there, so we'll highlight it using our dear friend "script.aculo.us":http://script.aculo.us/.

So there you have it.  Render a slow-loading partial in your Rails application, using AJAX.

Note:
Admittedly this pattern takes a bit of elbow grease to build out.  If you have alternative suggestions, aligning more closely with The Rails Way, please let me know.  If this pattern seems  to mass the muster however, I'll consider appending to one of the existing helpers to facilitate the Ajax.Request bits, to make this a little smoother.
